---
title: "Improving power of single cell eQTL with factorization"
author: "Lifan Liang"
date: "2025-01-14"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Simulation with a known latent factor

```{r,setup=T}
sim_factor <- function(alpha=0.25, beta=0.4, eps0=1.0, eps1=0.3){
  res <- numeric(6L)
  names(res) <- c("beta.Z","score.Z","p.Z",
                  "beta.y","score.y","p.y")
  x = rnorm(100,sd=1)
  Z = alpha*x + rnorm(100,sd=eps0)
  y = beta*Z + rnorm(100,sd=eps1)
  
  res[c("beta.Z","score.Z","p.Z")] <- summary(lm(Z~x))$coefficients[2,c(1,3,4)]
  res[c("beta.y","score.y","p.y")] <- summary(lm(y~x))$coefficients[2,c(1,3,4)]
  
  res
}
```

We generated data with one latent factor $Z$ that affects one traits, $Y$. The generative process is as follow:

$$
X \sim Normal(0,1)
\\
\epsilon_0 \sim Normal(0,\sigma_0^2)
\\
\\
\epsilon_1 \sim Normal(0,\sigma_1^2)
\\
Z = \alpha X + \epsilon_0
\\
Y = \beta Z + \epsilon_1
$$

Most parameters are fixed during simulation. We set $\alpha = 0.25$, $\sigma_0=1$, In this way, we have:
$$
PVE(Z \sim X) =\dfrac{\alpha^2 var(X)}{\alpha^2 var(X) + \sigma_0^2} \approx 5.88\%
$$
we set $\beta_1 = 0.4$. Given that :

$$
PVE(Y\sim X)=\dfrac{\alpha^2\beta^2var(X)}{\alpha^2\beta^2var(X)+\beta^2\sigma_0^2+\sigma_1^2}
$$. 

In order to approximate realistic PVE of eQTL, which ranges around 2% ~ 5%, we set $\sigma_1 \in {0.2,0.3,0.4}$ so that $PVE(Y_1 \sim X)$ ranges around 3.03% and 4.76%. We compared the t score and P values of regressing X against Y versus X against X. 100 samples were drawn from the simulation each time. 

```{r,echo=F}
library(ggplot2)
par(mfrow=c(1,3))
ress <- do.call(rbind, lapply(1:100,function(x){sim_factor(eps1=0.2)}))
plot(abs(ress[,"score.y"]), abs(ress[,"score.Z"]), pch=20,
     ylim=c(0,5), xlim=c(0,5),col=3,main="sigma1=0.2",
     ylab="t score for Z~X", xlab="t score for Y~X")
lines(x=c(-4,6),y=c(-4,6),col=1)

ress <- do.call(rbind, lapply(1:100,function(x){sim_factor(eps1=0.3)}))
plot(abs(ress[,"score.y"]), abs(ress[,"score.Z"]), main="sigma1=0.3", pch=20,
     ylim=c(0,5), xlim=c(0,5),col=3,ylab="t score for Z~X", xlab="t score for Y~X")
lines(x=c(-4,6),y=c(-4,6),col=1)


ress <- do.call(rbind, lapply(1:100,function(x){sim_factor(eps1=0.4)}))
plot(abs(ress[,"score.y"]), abs(ress[,"score.Z"]),main="sigma1=0.4", pch=20,
     ylim=c(0,5), xlim=c(0,5),col=3,ylab="t score for Z~X", xlab="t score for Y~X")
lines(x=c(-4,6),y=c(-4,6),col=1)

#legend(col=c(3,2),legend = c("Y1~X","Y2~X"))
```


### Theoretical power gain

In fact, we can directly derive the power gain from this simple simulation scenario. For instance, let's focus on $Y$, we have:

$$
Y = \alpha \beta X + \epsilon_1 + \beta_1 \epsilon_0
$$

Hence, we can derive the expected t score of X:

$$
Tscore(Y \sim X) ^2= \dfrac{N\alpha^2 \beta^2}{\sigma_1^2+\beta^2\sigma_0^2}
$$
On the other hand,  we have:
$$
Tscore(Z \sim X)^2 = \dfrac{N\alpha^2}{\sigma_0^2}
$$
So the expected ratio between the two should be:
$$
(\dfrac{Tscore(Z \sim X)}{Tscore(Y \sim X)})^2 = 1 + (\dfrac{\sigma_1}{\sigma_0 \beta})^2
$$

Therefore, we will always gain power if we know the latent factor as ground truth. 

## Simulation with one unknown common factor

This simulation follows the same scenario as the one above. The difference is that $Z$ is unknown and there are ten traits ($[Y_1,Y_2,...,Y_{10}$). All $\beta$ from $Z$ to $Y$ is 0.4. We performed PCA to estimate $Z$.

```{r}
sim_10trait <- function(alpha=0.25, beta=0.4, eps0=1.0, eps1=0.3, N=100){
  x = rnorm(N,sd=1)
  Z = alpha*x + rnorm(N,sd=eps0)
  y = matrix(0,nrow = N,ncol=10)
  for(i in 1: ncol(y)){
    y[,i] <- beta*Z + rnorm(N,sd=eps1)
  }
  list(x=x,Z=Z,y=y)
}
```

### Estimating Z

We used the first principle component as the estimator for Z after standardizing Y. Below is the scatter plot between $\hat{Z}$ and $Z$.

```{r}
set.seed(12)
dat <- sim_10trait()
y1 <- scale(dat$y)
pcs <- prcomp(y1)
z_hat <- pcs$x[,1]
plot(z_hat, dat$Z, ylab="Oracle Z", xlab=" Estimated Z")
```

Elbow plot seems to suggest one or two PC is sufficient?

```{r}
plot(pcs$sdev^2/sum(pcs$sdev^2),ylab="PVE")
```

### Power comparison

Repeating the simulations 300 times. Oracle Z has the highest power, followed by $\hat{Z} \sim x$.

```{r}
Nrep = 300

factor.res <- matrix(nrow=Nrep,ncol=3)
oracle.res <- matrix(nrow=Nrep,ncol=3)
marg <- list()
marg$beta <- matrix(nrow=Nrep,ncol=10)
marg$tstat <- matrix(nrow=Nrep,ncol=10)
marg$pval <- matrix(nrow=Nrep,ncol=10)
  
for(i in 1:Nrep) {
  dat <- sim_10trait(N=100)
  pcs <- prcomp(dat$y,center = T,scale. = T)
  z_hat <- pcs$x[,1]
  factor.res[i,] <- summary(lm(z_hat~dat$x))$coefficients[2,c(1,3,4)]
  oracle.res[i,] <- summary(lm(dat$Z~dat$x))$coefficients[2,c(1,3,4)]
  #colnames(marg.res) <- c("beta","tstat","p")
  #print(i)
  for(j in 1:ncol(dat$y)) {
    marg$beta[i,j] <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,1]
    marg$tstat[i,j] <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,3]
    marg$pval[i,j] <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,4]
  }
}
dat1 <- abs(cbind(oracle.res[,2],cbind(factor.res[,2],marg$tstat))) # Combine T statistics
colnames(dat1) <- c("Oracle Z","Z hat",paste0("trait ",1:10))
boxplot(dat1,las=2,ylab="t statistics")
abline(h=median(abs(factor.res[,2])),col=2,lty=2,lwd=3)
```


The barplot below shows the frequency for P values < 0.05.

```{r}
dat2 <- abs(cbind(oracle.res[,3],cbind(factor.res[,3],marg$pval))) #combine p values
colnames(dat2) <- c("Oracle Z","Z hat",paste0("trait ",1:10))
barplot(colMeans(dat2<0.05),las=2)
```

### Frequency of rejecting null while there is no genetic effect. (FDR)

Situations where the 10 traits are still largely shared but genotype did not affect the trait $\alpha=0$. 

```{r}
Nrep = 300

factor.res <- matrix(nrow=Nrep,ncol=3)
oracle.res <- matrix(nrow=Nrep,ncol=3)
marg <- list()
marg$beta <- matrix(nrow=Nrep,ncol=10)
marg$tstat <- matrix(nrow=Nrep,ncol=10)
marg$pval <- matrix(nrow=Nrep,ncol=10)
  
for(i in 1:Nrep) {
  dat <- sim_10trait(N=100, alpha=0)
  pcs <- prcomp(dat$y,center = T,scale. = T)
  z_hat <- pcs$x[,1]
  factor.res[i,] <- summary(lm(z_hat~dat$x))$coefficients[2,c(1,3,4)]
  oracle.res[i,] <- summary(lm(dat$Z~dat$x))$coefficients[2,c(1,3,4)]
  #colnames(marg.res) <- c("beta","tstat","p")
  #print(i)
  for(j in 1:ncol(dat$y)) {
    marg$beta[i,j] <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,1]
    marg$tstat[i,j] <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,3]
    marg$pval[i,j] <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,4]
  }
}
dat3 <- abs(cbind(oracle.res[,3],cbind(factor.res[,3],marg$pval))) #combine p values
colnames(dat3) <- c("Oracle Z","Z hat",paste0("trait ",1:10))
barplot(colMeans(dat3<0.05),las=2)
```