---
title: "Improving power of single cell eQTL with factorization"
author: "Lifan Liang"
date: "2025-01-14"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Simulation with a known latent factor

```{r,setup=T}
sim_factor <- function(alpha=0.25, beta=0.4, eps0=1.0, eps1=0.3){
  res <- numeric(6L)
  names(res) <- c("beta.Z","score.Z","p.Z",
                  "beta.y","score.y","p.y")
  x = rnorm(100,sd=1)
  Z = alpha*x + rnorm(100,sd=eps0)
  y = beta*Z + rnorm(100,sd=eps1)
  
  res[c("beta.Z","score.Z","p.Z")] <- summary(lm(Z~x))$coefficients[2,c(1,3,4)]
  res[c("beta.y","score.y","p.y")] <- summary(lm(y~x))$coefficients[2,c(1,3,4)]
  
  res
}
```

We generated data with one latent factor $Z$ that affects one trait, $Y$. The generative process is as follow:

$$
X \sim Normal(0,1)
\\
\epsilon_0 \sim Normal(0,\sigma_0^2)
\\
\\
\epsilon_1 \sim Normal(0,\sigma_1^2)
\\
Z = \alpha X + \epsilon_0
\\
Y = \beta Z + \epsilon_1
$$

Most parameters are fixed during simulation. We set $\alpha = 0.25$, $\sigma_0=1$, In this way, we have:
$$
PVE(Z \sim X) =\dfrac{\alpha^2 var(X)}{\alpha^2 var(X) + \sigma_0^2} \approx 5.88\%
$$
we set $\beta_1 = 0.4$. Given that :

$$
PVE(Y\sim X)=\dfrac{\alpha^2\beta^2var(X)}{\alpha^2\beta^2var(X)+\beta^2\sigma_0^2+\sigma_1^2}
$$. 

In order to approximate realistic PVE of eQTL, which ranges around 2% ~ 5%, we set $\sigma_1 \in {0.2,0.3,0.4}$ so that $PVE(Y_1 \sim X)$ ranges around 3.03% and 4.76%. We compared the t score and P values of regressing X against Y versus X against X. 100 samples were drawn from the simulation each time. 

```{r,echo=F}
library(ggplot2)
par(mfrow=c(1,3))
ress <- do.call(rbind, lapply(1:100,function(x){sim_factor(eps1=0.2)}))
plot(abs(ress[,"score.y"]), abs(ress[,"score.Z"]), pch=20,
     ylim=c(0,5), xlim=c(0,5),col=3,main="sigma1=0.2",
     ylab="t score for Z~X", xlab="t score for Y~X")
lines(x=c(-4,6),y=c(-4,6),col=1)

ress <- do.call(rbind, lapply(1:100,function(x){sim_factor(eps1=0.3)}))
plot(abs(ress[,"score.y"]), abs(ress[,"score.Z"]), main="sigma1=0.3", pch=20,
     ylim=c(0,5), xlim=c(0,5),col=3,ylab="t score for Z~X", xlab="t score for Y~X")
lines(x=c(-4,6),y=c(-4,6),col=1)


ress <- do.call(rbind, lapply(1:100,function(x){sim_factor(eps1=0.4)}))
plot(abs(ress[,"score.y"]), abs(ress[,"score.Z"]),main="sigma1=0.4", pch=20,
     ylim=c(0,5), xlim=c(0,5),col=3,ylab="t score for Z~X", xlab="t score for Y~X")
lines(x=c(-4,6),y=c(-4,6),col=1)

#legend(col=c(3,2),legend = c("Y1~X","Y2~X"))
```


### Theoretical power gain

In fact, we can directly derive the power gain from this simple simulation scenario. For instance, let's focus on $Y$, we have:

$$
Y = \alpha \beta X + \epsilon_1 + \beta_1 \epsilon_0
$$

Hence, we can derive the expected t score of X:

$$
Tscore(Y \sim X) ^2= \dfrac{N\alpha^2 \beta^2}{\sigma_1^2+\beta^2\sigma_0^2}
$$
On the other hand,  we have:
$$
Tscore(Z \sim X)^2 = \dfrac{N\alpha^2}{\sigma_0^2}
$$
So the expected ratio between the two should be:
$$
(\dfrac{Tscore(Z \sim X)}{Tscore(Y \sim X)})^2 = 1 + (\dfrac{\sigma_1}{\sigma_0 \beta})^2
$$

Therefore, we will always gain power if we know the latent factor as ground truth. 

## Simulation with one unknown common factor

This simulation follows the same scenario as the one above. The difference is that $Z$ is unknown and there are ten traits ($[Y_1,Y_2,...,Y_{10}$). All $\beta$ from $Z$ to $Y$ is 0.4. We performed PCA to estimate $Z$.

```{r}
sim_10trait <- function(alpha=0.25, beta=0.4, eps0=1.0, eps1=0.3, N=100){
  x = rnorm(N,sd=1)
  Z = alpha*x + rnorm(N,sd=eps0)
  y = matrix(0,nrow = N,ncol=10)
  for(i in 1: ncol(y)){
    y[,i] <- beta*Z + rnorm(N,sd=eps1)
  }
  list(x=x,Z=Z,y=y)
}
```

### Estimating Z

We used the first principle component as the estimator for Z after standardizing Y. Below is the scatter plot between $\hat{Z}$ and $Z$.

```{r}
set.seed(12)
dat <- sim_10trait()
y1 <- scale(dat$y)
pcs <- prcomp(y1)
z_hat <- pcs$x[,1]
plot(z_hat, dat$Z, ylab="Oracle Z", xlab=" Estimated Z")
```

Elbow plot seems to suggest one or two PC is sufficient?

```{r}
plot(pcs$sdev^2/sum(pcs$sdev^2),ylab="PVE")
```

### Power comparison

Repeating the simulations 300 times. Oracle Z has the highest power, followed by $\hat{Z} \sim x$.

```{r}
Nrep = 300

factor.res <- matrix(nrow=Nrep,ncol=3)
oracle.res <- matrix(nrow=Nrep,ncol=3)
marg <- list()
marg$beta <- matrix(nrow=Nrep,ncol=10)
marg$tstat <- matrix(nrow=Nrep,ncol=10)
marg$pval <- matrix(nrow=Nrep,ncol=10)
  
for(i in 1:Nrep) {
  dat <- sim_10trait(N=100)
  pcs <- prcomp(dat$y,center = T,scale. = T)
  z_hat <- pcs$x[,1]
  factor.res[i,] <- summary(lm(z_hat~dat$x))$coefficients[2,c(1,3,4)]
  oracle.res[i,] <- summary(lm(dat$Z~dat$x))$coefficients[2,c(1,3,4)]
  #colnames(marg.res) <- c("beta","tstat","p")
  #print(i)
  for(j in 1:ncol(dat$y)) {
    marg$beta[i,j] <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,1]
    marg$tstat[i,j] <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,3]
    marg$pval[i,j] <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,4]
  }
}
dat1 <- abs(cbind(oracle.res[,2],cbind(factor.res[,2],marg$tstat))) # Combine T statistics
colnames(dat1) <- c("Oracle Z","Z hat",paste0("trait ",1:10))
boxplot(dat1,las=2,ylab="t statistics")
abline(h=median(abs(factor.res[,2])),col=2,lty=2,lwd=3)
```


The barplot below shows the frequency for P values < 0.05.

```{r}
dat2 <- cbind(oracle.res[,3],cbind(factor.res[,3],marg$pval)) #combine p values
colnames(dat2) <- c("Oracle Z","Z hat",paste0("trait ",1:10))
barplot(colMeans(dat2<0.05),las=2)
```

### Frequency of rejecting null (P<0.05) while there is no genetic effect. 

Situations where the 10 traits are still largely shared but genotype did not affect the trait $\alpha=0$. 

```{r}
Nrep = 300

factor.res <- matrix(nrow=Nrep,ncol=3)
oracle.res <- matrix(nrow=Nrep,ncol=3)
marg <- list()
marg$beta <- matrix(nrow=Nrep,ncol=10)
marg$tstat <- matrix(nrow=Nrep,ncol=10)
marg$pval <- matrix(nrow=Nrep,ncol=10)
  
for(i in 1:Nrep) {
  dat <- sim_10trait(N=100, alpha=0)
  pcs <- prcomp(dat$y,center = T,scale. = T)
  z_hat <- pcs$x[,1]
  factor.res[i,] <- summary(lm(z_hat~dat$x))$coefficients[2,c(1,3,4)]
  oracle.res[i,] <- summary(lm(dat$Z~dat$x))$coefficients[2,c(1,3,4)]
  #colnames(marg.res) <- c("beta","tstat","p")
  #print(i)
  for(j in 1:ncol(dat$y)) {
    marg$beta[i,j] <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,1]
    marg$tstat[i,j] <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,3]
    marg$pval[i,j] <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,4]
  }
}
dat3 <- abs(cbind(oracle.res[,3],cbind(factor.res[,3],marg$pval))) #combine p values
colnames(dat3) <- c("Oracle Z","Z hat",paste0("trait ",1:10))
barplot(colMeans(dat3<0.05),las=2)
```


### Simulation with one SNP affecting one latent factor and other SNPs with direct effects

```{r}
library(flashier)

sim_5trait <- function(alpha=0.25, beta=0.4, gamma=0.05, eps0=1.0, eps1=0.3, N=100){
  x1 = rnorm(N,sd=1)
  x2 = matrix(rnorm(N*5,sd=1), nrow=N, ncol=5)
  Z = alpha*x1 + rnorm(N,sd=eps0)
  y = matrix(0,nrow = N,ncol=5)
  for(i in 1: ncol(y)){
    y[,i] <- beta*Z + rnorm(N,sd=eps1) + x2[,i]*gamma
  }
  list(x1=x1,x2=x2,Z=Z,y=y)
}

```

```{r}
dat.sim <- sim_5trait()
for(i in 1:ncol(dat.sim$y)) {
  
}
summary(lm(dat.sim$y[,2]~dat.sim$x1))
summary(lm(dat.sim$Z~dat.sim$x1))

```


### Simulation with two latent factors

We added another factor that affects 5 traits ($Y_1,..., Y_5$). The parameters are set so that $PVE(Z\sim X)=2\%$ and $PVE(Y\sim X) \approx 1.8\%$

```{r}
sim_10trait2 <- function(alpha1=0.1, alpha2=0.1 ,beta1=0.3, beta2=0.4, eps0=0.7, eps1=0.4, N=100){
  x = rnorm(N,sd=1)
  Z1 = alpha1*x + rnorm(N,sd=eps0)
  Z2 = alpha2*x + rnorm(N,sd=eps0)
  y = matrix(0,nrow = N,ncol=10)
  for(i in 1: ncol(y)){
    y[,i] <- beta1*Z1 + rnorm(N,sd=eps1)
  }
  for(i in 1:3){ ### Add the effect of Z2
    y[,i] <- y[,i] + beta2*Z2
  }
  list(x=x,Z=cbind(Z1,Z2),y=y)
}
```


```{r}
library(pheatmap)
dat <- sim_10trait2()
y1 <- scale(dat$y)
pcs <- prcomp(y1)
pheatmap(cor(pcs$x[,1:4], dat$Z)**2,cluster_cols = F,cluster_rows = F,
         display_numbers=round(cor(pcs$x[,1:4], dat$Z)**2,3),
         fontsize_number = 15, cellheight = 20, cellwidth=60)
```

```{r}
plot(pcs$sdev^2/sum(pcs$sdev^2),ylab="PVE")
```

PCA results have captured one factor. My conjecture is that the two factors are correlated by the genetic effect. So PCA tends to attribute all genetic effects to the first PC.

```{r}
z_hat <- pcs$x[,1]
plot(z_hat, dat$Z[,1], ylab="Oracle Z1", xlab=" Estimated Z")
```

```{r}
z_hat <- pcs$x[,2]
plot(z_hat, dat$Z[,2], ylab="Oracle Z2", xlab=" Estimated Z")
```

```{r}
Nrep = 300

factor.res1 <- matrix(nrow=Nrep,ncol=3)
oracle.z1 <- matrix(nrow=Nrep,ncol=3)
factor.res2 <- matrix(nrow=Nrep,ncol=3)
oracle.z2 <- matrix(nrow=Nrep,ncol=3)
marg <- list()
marg$beta <- matrix(nrow=Nrep,ncol=10)
marg$tstat <- matrix(nrow=Nrep,ncol=10)
marg$pval <- matrix(nrow=Nrep,ncol=10)
  
for(i in 1:Nrep) {
  dat <- sim_10trait2(N=100)
  pcs <- prcomp(dat$y,center = T,scale. = T)
  z_hat <- pcs$x[,1:2]
  factor.res1[i,] <- summary(lm(z_hat[,1]~dat$x))$coefficients[2,c(1,3,4)]
  factor.res2[i,] <- summary(lm(z_hat[,2]~dat$x))$coefficients[2,c(1,3,4)]
  oracle.z1[i,] <- summary(lm(dat$Z[,1]~dat$x))$coefficients[2,c(1,3,4)]
  oracle.z2[i,] <- summary(lm(dat$Z[,2]~dat$x))$coefficients[2,c(1,3,4)]
  #colnames(marg.res) <- c("beta","tstat","p")
  #print(i)
  for(j in 1:ncol(dat$y)) {
    temp <- summary(lm(dat$y[,j]~dat$x))$coefficients[2,]
    marg$beta[i,j] <- temp[1]
    marg$tstat[i,j] <- temp[3]
    marg$pval[i,j] <- temp[4]
  }
}

```


### Frequency of rejecting null (nominal PV < 0.05)

```{r}
dat2 <- do.call(cbind, list(oracle_Z1=oracle.z1[,3],oracle_Z2=oracle.z2[,3],
                            Z1_hat=factor.res1[,3],Z2_hat=factor.res2[,3]))
dat2 <- cbind(dat2, marg$pval)
colnames(dat2)[5:14] <- paste0("trait ",1:10)
barplot(colMeans(dat2<0.05),las=2)
```

## Simulation without genotypes

In this case, the two factors are stastically independent from each other.

```{r}
### simulation without X (genotypes)
sim_10trait3 <- function(beta1=0.3, beta2=0.4, eps0=1.0, eps1=0.4, N=100){
  Z1 = rnorm(N,sd=eps0)
  Z2 = rnorm(N,sd=eps0)
  y = matrix(0,nrow = N,ncol=10)
  for(i in 1: ncol(y)){
    y[,i] <- beta1*Z1 + rnorm(N,sd=eps1)
  }
  for(i in 1:3){ ### Add the effect of Z2
    y[,i] <- y[,i] + beta2*Z2
  }
  list(Z=cbind(Z1,Z2),y=y)
}
```

PCA results correlates with the two factors better.

```{r}
dat <- sim_10trait3()
y1 <- scale(dat$y)
pcs <- prcomp(y1)
pheatmap(cor(pcs$x[,1:4], dat$Z)**2, cluster_cols = F, cluster_rows = F,
         display_numbers=round(cor(pcs$x[,1:4],dat$Z)**2,3),
         fontsize_number = 15, cellheight = 20, cellwidth=60)
```


FastICA identified similar results but factors are usually more distinguished.

```{r}
library(ica)

res <- icafast(dat$y,2)
dat1 <- cor(res$S,dat$Z)**2
pheatmap(dat1, cluster_cols = F, cluster_rows = F,
         display_numbers=round(dat1,3),
         fontsize_number = 15, cellheight = 20, cellwidth=60)
```

## Simulation with two SNPs affecting two factors seperately

```{r}
### simulation without 2 SNPs affecting two factors
sim_10trait4 <- function(alpha1=0.1, alpha2=0.1, beta1=0.3, beta2=0.3, eps0=1.0, eps1=0.4, N=100){
  X1 = rnorm(N,sd=1)
  X2 = rnorm(N,sd=1)
  Z1 = alpha1*X1 + rnorm(N,sd=eps0)
  Z2 = alpha2*X2 + rnorm(N,sd=eps0)
  y = matrix(0,nrow = N,ncol=10)
  for(i in 1: ncol(y)){
    y[,i] <- beta1*Z1 + rnorm(N,sd=eps1)
  }
  for(i in 1:3){ ### Add the effect of Z2
    y[,i] <- y[,i] + beta2*Z2
  }
  list(x=cbind(X1,X2),Z=cbind(Z1,Z2),y=y)
}
```

Heatmap below shows the $R^2$ between PCs and oracle factor values. The first two PCs correlate well with the oracle factor values. 

```{r}
set.seed(20)
dat <- sim_10trait4()
#y1 <- scale(dat$y)
pcs <- prcomp(dat$y,center = T,scale. = T)
pheatmap(cor(pcs$x[,1:4], dat$Z)**2, cluster_cols = F, cluster_rows = F,
         display_numbers=round(cor(pcs$x[,1:4],dat$Z)**2,3),
         fontsize_number = 15, cellheight = 20, cellwidth=60)
```

We repeated the simulation 300 times and check the statical power.

```{r}
Nrep = 300

factor.res1 <- matrix(nrow=Nrep,ncol=3)
oracle.z1 <- matrix(nrow=Nrep,ncol=3)
factor.res2 <- matrix(nrow=Nrep,ncol=3)
oracle.z2 <- matrix(nrow=Nrep,ncol=3)
marg1 <- list()
marg1$beta <- matrix(nrow=Nrep,ncol=10)
marg1$tstat <- matrix(nrow=Nrep,ncol=10)
marg1$pval <- matrix(nrow=Nrep,ncol=10)
marg2 <- marg1

for(i in 1:Nrep) {
  dat <- sim_10trait4(N=100)
  pcs <- prcomp(dat$y,center = T,scale. = T)
  z_hat <- pcs$x[,1:2]
  factor.res1[i,] <- summary(lm(z_hat[,1]~dat$x[,1]))$coefficients[2,c(1,3,4)]
  factor.res2[i,] <- summary(lm(z_hat[,2]~dat$x[,2]))$coefficients[2,c(1,3,4)]
  oracle.z1[i,] <- summary(lm(dat$Z[,1]~dat$x[,1]))$coefficients[2,c(1,3,4)]
  oracle.z2[i,] <- summary(lm(dat$Z[,2]~dat$x[,2]))$coefficients[2,c(1,3,4)]
  #colnames(marg.res) <- c("beta","tstat","p")
  #print(i)
  for(j in 1:ncol(dat$y)) {
    temp <- summary(lm(dat$y[,j]~dat$x[,1]))$coefficients[2,]
    marg1$beta[i,j] <- temp[1]
    marg1$tstat[i,j] <- temp[3]
    marg1$pval[i,j] <- temp[4]
    temp <- summary(lm(dat$y[,j]~dat$x[,2]))$coefficients[2,]
    marg2$beta[i,j] <- temp[1]
    marg2$tstat[i,j] <- temp[3]
    marg2$pval[i,j] <- temp[4]
  }
}

```

```{r}
library(ggplot2)
dat2 <- do.call(cbind, list(oracle_Z1=oracle.z1[,3],oracle_Z2=oracle.z2[,3],
                            Z1_hat=factor.res1[,3],Z2_hat=factor.res2[,3]))
dat2 <- cbind(cbind(dat2, marg1$pval), marg2$pval)
colnames(dat2)[5:24] <- paste0("trait ",1:10)
dat3 <- data.frame(frequency=colMeans(dat2<0.05),
                   type=rep(c("Oracle","Estimated","Marginal"),times=c(2,2,20)),
                   names=colnames(dat2))
dat3$names[c(1,3,5:14)] <- paste(colnames(dat2)[c(1,3,5:14)],"~","X1")
dat3$names[c(2,4,15:24)] <- paste(colnames(dat2)[c(2,4,15:24)],"~","X2")

ggplot(dat3,aes(x=names,y=frequency,fill=type)) + geom_bar(stat="identity") + 
  theme_bw() + theme(axis.text.x = element_text(angle = 45,hjust=1))
```

## eQTL at different cellular resolution

I run eQTL mapping with three aggregation approach: (1) Take average of expression across all cells per donor; (2) take average of expression within the excitatory cell type (npglut and nmglut); (3) take average of expression within inhibitory cell types (GABA). All eQTL mapping was run with 5 genotype PCs, 15 expression PCs, and 95 donors. Total eQTL identified 8072 eGenes; excitatory eQTL identified 6926 eGenes; inhibitory eQTL identified 5155 eGenes.


![](assets/psbulk_eqtl_overlap.png)

### Comparing with eQTL within single context

![](assets/gaba1_inh_total.png)

![](assets/npglut1_exc_total.png)
